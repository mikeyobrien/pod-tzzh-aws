(ns generate
  (:require [babashka.classpath :as c]
            [clojure.java.shell :as shell]
            [clojure.string :as s]))
(let [cp (-> (shell/sh "clojure" "-Spath" "-Sdeps" (str '{:deps {comb {:mvn/version "0.1.1"}}}))
             :out
             s/trim)]
  (c/add-classpath cp))
(require '[comb.template :as template])

(def SERVICES
  "Services to generate code for"
  ["athena"
   "glue"
   "kafka"
   "kinesis"
   "lambda"
   "sqs"
   "ssm"
   "dynamodb"
   "s3"])

(defn read-service-source
  "Read the source file from a given service in the go sdk"
  [service-name]
  (let [go-path (System/getenv "GOPATH")
        api-go (format "%s/src/github.com/aws/aws-sdk-go/service/%s/api.go" go-path service-name)]
    (slurp api-go)))

(defn find-fns
  "Extract all the fns to be generated from the source file"
  [service-source]
  (->> service-source
       (re-seq #"func .* (\w+(?<!(Pages|Request)))\(input.*Input")
       (map (fn [[_ f]] f))))

(defn find-services-fns
  "Build a sorted map of service: fns for the given services"
  [services]
  (reduce (fn [acc service-name]
            (assoc acc service-name (-> service-name
                                        read-service-source
                                        find-fns)))
          (sorted-map)
          services))

(defn clj-fn-name
  "Converts from the the aws sdk to the cljfunction name"
  [aws-fn-name]
  (->> (s/split aws-fn-name #"(?=[A-Z])")
       (map s/lower-case)
       (s/join "-")))

(defn aws-input-name
  [aws-fn-name]
  (str aws-fn-name "Input"))

(defn aws-output-name
  [aws-fn-name]
  (str aws-fn-name "Output"))

(def quoted-get-paginator
  (quote
    (defn get-paginator
      "Returns a fn that lazily fetches the pages for a given aws fn"
      [page-fn]
      (fn get-pages
        ([]
         (get-pages {}))
        ([input]
         (lazy-seq
           (let [page (page-fn input)
                 next-continuation-token (:NextContinuationToken page)
                 next-token (:NextToken page)
                 next-marker (:NextMarker page)] ;; some services use different types of continuation tokens
             (cond next-continuation-token
                     (cons page (get-pages (assoc input :ContinuationToken next-continuation-token)))
                   next-token
                     (cons page (get-pages (assoc input :NextToken next-token)))
                   next-marker
                     (cons page (get-pages (assoc input :Marker next-marker)))
                   :else
                     [page]))))))))

(def t
  "
  // Code generated by generate.clj DO NOT EDIT
  package aws

  import (
  \"encoding/json\"
  \"github.com/aws/aws-sdk-go/aws/session\"
  <% (doseq [[ns-name _] namespaces]
  %> \"github.com/aws/aws-sdk-go/service/<%= ns-name %>\"
  <% ) %>
  \"github.com/tzzh/pod-tzzh-aws/babashka\"
  )

  func ProcessMessage(message *babashka.Message) {

  if message.Op == \"describe\" {
    response := &babashka.DescribeResponse{
        Format: \"json\",
        Namespaces: []babashka.Namespace{
            {Name: \"pod.tzzh.paginator\",
             Vars: []babashka.Var{
                {Name: \"get-paginator\",
                 Code: `<%= paginator %>`},
                },
             },
        <% (doseq [[ns-name ns-fns] namespaces]
          %>{Name: \"pod.tzzh.<%= ns-name %>\",
            Vars: []babashka.Var{
            <% (doseq [ns-fn ns-fns]
            %>  {Name: \"<%= (clj-fn-name ns-fn) %>\"},
            <% ) %>
            },
           },
        <% ) %>
        },
    }
    babashka.WriteDescribeResponse(response)

  } else if message.Op == \"invoke\" {

            switch message.Var {
  <% (doseq [[ns-name ns-fns] namespaces
           ns-fn ns-fns]
            %>case \"pod.tzzh.<%= ns-name %>/<%= (clj-fn-name ns-fn) %>\":

    svc := <%= ns-name %>.New(session.New())
    input := &<%= ns-name %>.<%= (aws-input-name ns-fn)%>{}
    inputList := []<%= ns-name %>.<%= (aws-input-name ns-fn)%>{}
    err := json.Unmarshal([]byte(message.Args), &inputList)
    if err != nil {
        babashka.WriteErrorResponse(message, err)
    } else {
          if len(inputList) > 0 {
              input = &inputList[0]
          }
          res, err := svc.<%= ns-fn %>(input)
          if err != nil {
              babashka.WriteErrorResponse(message, err)
          } else {
              babashka.WriteInvokeResponse(message, res)
          }
      }
  <% ) %>
          }
  }
  }
")

(when (= *file* (System/getProperty "babashka.file"))
  (let [aws-go "./aws/aws.go"
        aws-api (find-services-fns SERVICES)]
    (spit aws-go (template/eval t {:namespaces aws-api
                                   :paginator (str quoted-get-paginator)}))
    (let [{:keys [err exit]} (shell/sh "go" "fmt" aws-go)]
      (when-not (empty? err)
        (print err))
      (System/exit exit))))
